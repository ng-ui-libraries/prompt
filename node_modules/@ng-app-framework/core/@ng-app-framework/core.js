import { EventEmitter, Injectable, NgModule } from '@angular/core';
import { Observable } from 'rxjs/Rx';

class Value {
    /**
     * @param {?} value
     * @return {?}
     */
    static isProvided(value) {
        return value !== undefined && value !== null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static isScalar(value) {
        return (/string|number|boolean/).test(typeof value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static isNumber(value) {
        return this.isNotNull(value) && this.isTypeOf(Number, value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static isBoolean(value) {
        return this.isNotNull(value) && this.isTypeOf(Boolean, value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static isString(value) {
        return this.isNotNull(value) && this.isTypeOf(String, value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static isArray(value) {
        return Array.isArray(value);
    }
    /**
     * @param {?} instance
     * @param {?} of
     * @return {?}
     */
    static isInstanceOf(instance, of) {
        if (of === Object && Value.isArray(instance)) {
            return false;
        }
        return this.isSameClassAs(instance, of) || instance instanceof of;
    }
    /**
     * @param {?} instance
     * @param {?} otherClass
     * @return {?}
     */
    static isSameClassAs(instance, otherClass) {
        return this.isNotNull(instance) && instance['constructor'] !== undefined && instance.constructor === otherClass;
    }
    /**
     * @param {?} type
     * @param {?} value
     * @return {?}
     */
    static isTypeOf(type, value) {
        if (!this.isNotNull(value)) {
            return false;
        }
        if (this.isSameClassAs(value, type)) {
            return true;
        }
        if (this.isScalarType(type)) {
            return this.isScalar(value) && this.isSameClassAs(value, type);
        }
        return !this.isScalar(value)
            && !this.isArray(value)
            && this.isInstanceOf(value, type);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static hasArrayElements(value) {
        return this.isNotNull(value) && this.isArray(value) && this.hasLength(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static hasProperties(value) {
        return this.isNotNull(value) && !this.isArray(value) && this.isInstanceOf(value, Object) && Object.keys(value).length > 0;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static isNotNull(value) {
        return value !== undefined && value !== null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static isDefined(value) {
        return value !== undefined;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static hasLength(value) {
        return Value.isProvided(value) && Value.isDefined(value.length) && value.length > 0;
    }
    /**
     * @param {?} value
     * @param {?} key
     * @return {?}
     */
    static hasKey(value, key) {
        return this.isDefined(value[key]);
    }
    /**
     * @param {?} container
     * @param {?} value
     * @return {?}
     */
    static contains(container, value) {
        return (Value.isArray(container) || Value.isString(value)) && container.indexOf(value) > -1;
    }
    /**
     * @param {?} type
     * @return {?}
     */
    static isScalarType(type) {
        return type === String || type === Number || type === Boolean;
    }
    /**
     * @param {?} value
     * @param {?=} defaultValue
     * @return {?}
     */
    static coalesce(value, defaultValue = null) {
        if (Value.isString(value) && !Value.hasLength(value)) {
            return defaultValue;
        }
        return Value.isProvided(value) ? value : defaultValue;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static getDateAsString(value) {
        if (!Value.isProvided(value) || !Value.isSameClassAs(value, Date)) {
            return '';
        }
        let /** @type {?} */ dateString = this.getDatePaddedValue(value.getDate());
        let /** @type {?} */ monthString = this.getDatePaddedValue(value.getMonth() + 1);
        let /** @type {?} */ yearString = value.getFullYear();
        return `${yearString}-${monthString}-${dateString}`;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static getDatePaddedValue(value) {
        return value.toString().length === 2 ? '' + value : `0${value}`;
    }
}

class WindowEvents {
    constructor() {
        this.onMessage = new EventEmitter();
    }
    /**
     * @param {?} window
     * @return {?}
     */
    listen(window) {
        if (Value.isDefined(window.addEventListener)) {
            window.addEventListener('message', (event) => {
                this.onMessage.emit(event);
            });
        }
    }
}
WindowEvents.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
WindowEvents.ctorParameters = () => [];

class NgCoreModule {
    /**
     * @param {?} events
     */
    constructor(events) {
        events.listen(window);
    }
}
NgCoreModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    WindowEvents
                ]
            },] },
];
/**
 * @nocollapse
 */
NgCoreModule.ctorParameters = () => [
    { type: WindowEvents, },
];

/**
 * @param {?} target
 * @param {?} key
 * @return {?}
 */
function OnChange(target, key) {
    return {
        set: function (value) {
            let /** @type {?} */ hasChanged = this['_' + key] !== value;
            this['_' + key] = value;
            if (hasChanged && Value.isInstanceOf(this[key + 'Change'], EventEmitter)) {
                this[key + 'Change'].emit(value);
            }
        },
        get: function () {
            if (this['_' + key] === undefined) {
                target['_' + key] = target[key];
            }
            return this['_' + key];
        },
        enumerable: true,
        configurable: true
    };
}

class Async {
    /**
     * @param {?} elements
     * @param {?} doThis
     * @return {?}
     */
    static forEach$(elements, doThis) {
        return Observable.from(elements)
            .map((element, index) => {
            doThis(element, index);
            return element;
        });
    }
    /**
     * @param {?} elements
     * @param {?} mapTo
     * @return {?}
     */
    static map$(elements, mapTo) {
        return Observable.from(elements)
            .map((option, index) => mapTo(option, index));
    }
    /**
     * @param {?} observables
     * @return {?}
     */
    static merge$(observables) {
        return Observable.merge(...observables);
    }
    /**
     * @param {?} elements
     * @param {?} filterBy
     * @return {?}
     */
    static filter$(elements, filterBy) {
        return Observable.from(elements)
            .filter((option, index) => filterBy(option, index));
    }
    /**
     * @param {?} elements
     * @param {?} mapTo
     * @return {?}
     */
    static mapToObservable$(elements, mapTo) {
        return Observable.from(elements)
            .flatMap((element, index) => mapTo(element, index));
    }
    /**
     * @template T
     * @param {?} value
     * @return {?}
     */
    static getObservableForValue$(value) {
        return Observable.of(value);
    }
    /**
     * @param {?} observable
     * @param {?} condition
     * @param {?} then$
     * @param {?=} else$
     * @return {?}
     */
    static ifThenElse$(observable, condition, then$, else$) {
        return observable.flatMap(value => {
            if (condition(value)) {
                return then$(value);
            }
            return else$ ? else$(value) : Observable.empty();
        });
    }
}

class ObjectCombiner {
    /**
     * @param {?} baseObject
     * @param {?} otherObject
     * @param {?=} omitKeys
     * @return {?}
     */
    static combine(baseObject, otherObject, omitKeys = []) {
        Object.keys(baseObject)
            .filter(key => Value.isNotNull(otherObject[key]))
            .filter(key => !Value.contains(omitKeys, key))
            .forEach(key => {
            baseObject[key] = otherObject[key];
        });
    }
}

class SiteConfig {
}
SiteConfig.theme = '';
SiteConfig.contactUrl = '';
SiteConfig.logoUrl = '';
SiteConfig.unableToConnectMessage = `Unable to connect to remote server. Please <a href='${SiteConfig.contactUrl}'>contact support</a>.`;

class StringValue {
    /**
     * @param {?} target
     * @param {?} stringToReplace
     * @param {?} replacement
     * @return {?}
     */
    static replace(target, stringToReplace, replacement) {
        let /** @type {?} */ escaped = this.escapeCharacters(stringToReplace);
        let /** @type {?} */ escapedReplacement = this.escapeDollarSigns(replacement);
        return target.replace(new RegExp(escaped, 'g'), escapedReplacement);
    }
    /**
     * @param {?} string
     * @return {?}
     */
    static escapeDollarSigns(string) {
        return string.replace(/\$/g, '$$$$');
    }
    /**
     * @param {?} string
     * @return {?}
     */
    static escapeCharacters(string) {
        return string.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static isVowel(value) {
        return /[aeiouAEIOU]/.test(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static startsWithAVowel(value) {
        return this.isPopulated(value) && this.isVowel(value[0]);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static isPopulated(value) {
        return Value.isString(value) && Value.hasLength(value);
    }
}

const UnsubscribeAll = new EventEmitter();

class ValueInterpreter {
    /**
     * @param {?} valueProperty
     */
    constructor(valueProperty) {
        this.valueProperty = valueProperty;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    getValueOfObject(obj) {
        if (Value.isDefined(obj[this.valueProperty])) {
            return obj[this.valueProperty];
        }
        return obj;
    }
}

class ValueMapper {
    constructor() {
        this.propertyMap = {};
    }
    /**
     * @param {?} from
     * @param {?} to
     * @return {?}
     */
    addMap(from, to) {
        this.propertyMap[from] = to;
    }
    /**
     * @template T
     * @param {?} oldObject
     * @return {?}
     */
    mapToNewObject(oldObject) {
        let /** @type {?} */ obj = ({});
        for (let /** @type {?} */ key in this.propertyMap) {
            if (Value.isNotNull(oldObject[key])) {
                this.mapByKey(obj, key, oldObject);
            }
        }
        return obj;
    }
    /**
     * @param {?} newObject
     * @param {?} key
     * @param {?} oldObject
     * @return {?}
     */
    mapByKey(newObject, key, oldObject) {
        newObject[this.propertyMap[key]] = oldObject[key];
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { NgCoreModule, OnChange, Async, ObjectCombiner, SiteConfig, StringValue, UnsubscribeAll, Value, ValueInterpreter, ValueMapper, WindowEvents };
//# sourceMappingURL=core.js.map
